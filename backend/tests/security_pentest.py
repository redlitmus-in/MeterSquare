#!/usr/bin/env python3
"""
Security Penetration Tests for MeterSquare API
Tests for common vulnerabilities: SQL Injection, XSS, Auth Bypass, etc.

Usage:
    python tests/security_pentest.py --url http://localhost:8000
    python tests/security_pentest.py --url http://localhost:8000 --full
"""

import os
import sys
import json
import time
import argparse
import requests
from datetime import datetime
from typing import Dict, List, Tuple
from urllib.parse import quote

# Add parent directory to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))


class SecurityPenTester:
    """Penetration testing tool for MeterSquare API"""

    def __init__(self, base_url: str = 'http://localhost:8000'):
        self.base_url = base_url.rstrip('/')
        self.results = []
        self.passed = 0
        self.failed = 0
        self.session = requests.Session()

    # ============================================
    # SQL Injection Tests
    # ============================================

    SQL_INJECTION_PAYLOADS = [
        "' OR '1'='1",
        "'; DROP TABLE users; --",
        "1' OR '1'='1' --",
        "' UNION SELECT * FROM users --",
        "1; SELECT * FROM users",
        "' OR 1=1 --",
        "admin'--",
        "1' AND '1'='1",
        "'; EXEC xp_cmdshell('dir'); --",
        "1' WAITFOR DELAY '0:0:5' --"
    ]

    def test_sql_injection(self, endpoints: List[str] = None) -> List[Dict]:
        """Test endpoints for SQL injection vulnerabilities"""
        print("\n[TEST] SQL Injection Tests")
        print("-" * 50)

        if endpoints is None:
            endpoints = [
                '/api/users',
                '/api/projects',
                '/api/vendors',
                '/api/boq'
            ]

        issues = []

        for endpoint in endpoints:
            for payload in self.SQL_INJECTION_PAYLOADS[:5]:  # Test first 5 payloads
                try:
                    # Test in query parameter
                    url = f"{self.base_url}{endpoint}?id={quote(payload)}"
                    response = self.session.get(url, timeout=10)

                    # Check for SQL error messages in response
                    response_text = response.text.lower()
                    sql_errors = [
                        'sql syntax', 'mysql', 'postgresql', 'sqlite',
                        'ora-', 'sql server', 'syntax error',
                        'unterminated', 'invalid query'
                    ]

                    for error in sql_errors:
                        if error in response_text:
                            issue = {
                                'type': 'SQL_INJECTION',
                                'severity': 'CRITICAL',
                                'endpoint': endpoint,
                                'payload': payload,
                                'evidence': f"SQL error detected: {error}"
                            }
                            issues.append(issue)
                            self._log_issue(issue)
                            break

                except requests.exceptions.Timeout:
                    # Time-based SQL injection might have worked
                    issue = {
                        'type': 'SQL_INJECTION_TIME_BASED',
                        'severity': 'HIGH',
                        'endpoint': endpoint,
                        'payload': payload,
                        'evidence': "Request timed out - possible time-based injection"
                    }
                    issues.append(issue)
                except Exception as e:
                    pass  # Connection errors, etc.

        if not issues:
            print("   [PASS] No SQL injection vulnerabilities detected")
            self.passed += 1
        else:
            self.failed += 1

        return issues

    # ============================================
    # XSS (Cross-Site Scripting) Tests
    # ============================================

    XSS_PAYLOADS = [
        '<script>alert("XSS")</script>',
        '"><script>alert("XSS")</script>',
        "'-alert('XSS')-'",
        '<img src=x onerror=alert("XSS")>',
        '<svg onload=alert("XSS")>',
        'javascript:alert("XSS")',
        '<body onload=alert("XSS")>',
        '{{constructor.constructor("alert(1)")()}}'  # Template injection
    ]

    def test_xss(self, endpoints: List[str] = None) -> List[Dict]:
        """Test endpoints for XSS vulnerabilities"""
        print("\n[TEST] XSS (Cross-Site Scripting) Tests")
        print("-" * 50)

        if endpoints is None:
            endpoints = ['/api/health']

        issues = []

        for endpoint in endpoints:
            for payload in self.XSS_PAYLOADS[:4]:  # Test first 4 payloads
                try:
                    # Test in query parameter
                    url = f"{self.base_url}{endpoint}?search={quote(payload)}"
                    response = self.session.get(url, timeout=10)

                    # Check if payload is reflected without encoding
                    if payload in response.text:
                        issue = {
                            'type': 'XSS_REFLECTED',
                            'severity': 'HIGH',
                            'endpoint': endpoint,
                            'payload': payload,
                            'evidence': "Payload reflected in response without encoding"
                        }
                        issues.append(issue)
                        self._log_issue(issue)

                except Exception as e:
                    pass

        if not issues:
            print("   [PASS] No XSS vulnerabilities detected")
            self.passed += 1
        else:
            self.failed += 1

        return issues

    # ============================================
    # Authentication Bypass Tests
    # ============================================

    def test_auth_bypass(self) -> List[Dict]:
        """Test for authentication bypass vulnerabilities"""
        print("\n[TEST] Authentication Bypass Tests")
        print("-" * 50)

        issues = []
        protected_endpoints = [
            '/api/users',
            '/api/admin/users',
            '/api/projects',
            '/api/boq',
            '/api/change-requests'
        ]

        for endpoint in protected_endpoints:
            try:
                # Test without token
                response = self.session.get(
                    f"{self.base_url}{endpoint}",
                    timeout=10
                )

                if response.status_code == 200:
                    # Check if actual data is returned (not just error)
                    try:
                        data = response.json()
                        if data and 'error' not in str(data).lower():
                            issue = {
                                'type': 'AUTH_BYPASS',
                                'severity': 'CRITICAL',
                                'endpoint': endpoint,
                                'evidence': f"Endpoint accessible without authentication (status: {response.status_code})"
                            }
                            issues.append(issue)
                            self._log_issue(issue)
                    except:
                        pass

                # Test with invalid token
                headers = {'Authorization': 'Bearer invalid_token_12345'}
                response = self.session.get(
                    f"{self.base_url}{endpoint}",
                    headers=headers,
                    timeout=10
                )

                if response.status_code == 200:
                    issue = {
                        'type': 'AUTH_BYPASS_INVALID_TOKEN',
                        'severity': 'CRITICAL',
                        'endpoint': endpoint,
                        'evidence': "Endpoint accessible with invalid token"
                    }
                    issues.append(issue)
                    self._log_issue(issue)

            except Exception as e:
                pass

        if not issues:
            print("   [PASS] Authentication properly enforced")
            self.passed += 1
        else:
            self.failed += 1

        return issues

    # ============================================
    # IDOR (Insecure Direct Object Reference) Tests
    # ============================================

    def test_idor(self) -> List[Dict]:
        """Test for IDOR vulnerabilities"""
        print("\n[TEST] IDOR (Insecure Direct Object Reference) Tests")
        print("-" * 50)

        issues = []
        # Test accessing resources with sequential IDs
        idor_endpoints = [
            '/api/users/{id}',
            '/api/projects/{id}',
            '/api/boq/{id}'
        ]

        for endpoint_template in idor_endpoints:
            for test_id in [1, 2, 999, 9999]:
                endpoint = endpoint_template.replace('{id}', str(test_id))
                try:
                    response = self.session.get(
                        f"{self.base_url}{endpoint}",
                        timeout=10
                    )

                    # If we can access different user's data without auth
                    if response.status_code == 200:
                        try:
                            data = response.json()
                            if 'email' in str(data) or 'phone' in str(data):
                                issue = {
                                    'type': 'IDOR',
                                    'severity': 'HIGH',
                                    'endpoint': endpoint,
                                    'evidence': f"Sensitive data accessible via ID enumeration"
                                }
                                issues.append(issue)
                                self._log_issue(issue)
                                break  # One finding per endpoint is enough
                        except:
                            pass

                except Exception as e:
                    pass

        if not issues:
            print("   [PASS] No IDOR vulnerabilities detected")
            self.passed += 1
        else:
            self.failed += 1

        return issues

    # ============================================
    # Rate Limiting Tests
    # ============================================

    def test_rate_limiting(self) -> List[Dict]:
        """Test if rate limiting is properly implemented"""
        print("\n[TEST] Rate Limiting Tests")
        print("-" * 50)

        issues = []
        test_endpoint = '/api/health'

        try:
            # Send 100 requests rapidly
            start_time = time.time()
            success_count = 0

            for i in range(100):
                try:
                    response = self.session.get(
                        f"{self.base_url}{test_endpoint}",
                        timeout=5
                    )
                    if response.status_code == 200:
                        success_count += 1
                    elif response.status_code == 429:
                        # Rate limit hit - good!
                        print(f"   [PASS] Rate limiting active (triggered at request {i+1})")
                        self.passed += 1
                        return issues
                except:
                    pass

            elapsed = time.time() - start_time

            if success_count == 100:
                issue = {
                    'type': 'NO_RATE_LIMITING',
                    'severity': 'MEDIUM',
                    'endpoint': test_endpoint,
                    'evidence': f"100 requests completed in {elapsed:.2f}s without rate limiting"
                }
                issues.append(issue)
                self._log_issue(issue)
                self.failed += 1
            else:
                print(f"   [PASS] Rate limiting may be active ({success_count}/100 succeeded)")
                self.passed += 1

        except Exception as e:
            print(f"   [ERROR] Rate limit test failed: {e}")

        return issues

    # ============================================
    # Security Headers Tests
    # ============================================

    def test_security_headers(self) -> List[Dict]:
        """Test for missing security headers"""
        print("\n[TEST] Security Headers Tests")
        print("-" * 50)

        issues = []
        required_headers = {
            'X-Content-Type-Options': 'nosniff',
            'X-Frame-Options': ['DENY', 'SAMEORIGIN'],
            'X-XSS-Protection': '1',
            'Strict-Transport-Security': None,  # Any value is OK
            'Content-Security-Policy': None
        }

        try:
            response = self.session.get(f"{self.base_url}/api/health", timeout=10)

            for header, expected in required_headers.items():
                actual = response.headers.get(header)

                if actual is None:
                    issue = {
                        'type': 'MISSING_SECURITY_HEADER',
                        'severity': 'LOW',
                        'header': header,
                        'evidence': f"Header '{header}' is missing"
                    }
                    issues.append(issue)
                    print(f"   [WARN] Missing: {header}")
                else:
                    print(f"   [OK] {header}: {actual[:50]}...")

        except Exception as e:
            print(f"   [ERROR] Header test failed: {e}")

        if not issues:
            self.passed += 1
        else:
            self.failed += 1

        return issues

    # ============================================
    # Sensitive Data Exposure Tests
    # ============================================

    def test_sensitive_data_exposure(self) -> List[Dict]:
        """Test for sensitive data in responses"""
        print("\n[TEST] Sensitive Data Exposure Tests")
        print("-" * 50)

        issues = []
        sensitive_patterns = [
            ('password', 'CRITICAL'),
            ('password_hash', 'CRITICAL'),
            ('api_key', 'CRITICAL'),
            ('secret_key', 'CRITICAL'),
            ('ssn', 'CRITICAL'),
            ('credit_card', 'CRITICAL'),
            ('bank_account', 'CRITICAL')
        ]

        test_endpoints = ['/api/health', '/api/users', '/api/projects']

        for endpoint in test_endpoints:
            try:
                response = self.session.get(
                    f"{self.base_url}{endpoint}",
                    timeout=10
                )

                response_text = response.text.lower()

                for pattern, severity in sensitive_patterns:
                    if f'"{pattern}"' in response_text or f"'{pattern}'" in response_text:
                        issue = {
                            'type': 'SENSITIVE_DATA_EXPOSURE',
                            'severity': severity,
                            'endpoint': endpoint,
                            'pattern': pattern,
                            'evidence': f"Sensitive field '{pattern}' found in response"
                        }
                        issues.append(issue)
                        self._log_issue(issue)

            except Exception as e:
                pass

        if not issues:
            print("   [PASS] No sensitive data exposure detected")
            self.passed += 1
        else:
            self.failed += 1

        return issues

    # ============================================
    # Helper Methods
    # ============================================

    def _log_issue(self, issue: Dict):
        """Log a security issue"""
        severity_icons = {
            'CRITICAL': '[CRITICAL]',
            'HIGH': '[HIGH]',
            'MEDIUM': '[MEDIUM]',
            'LOW': '[LOW]'
        }
        icon = severity_icons.get(issue.get('severity'), '[???]')
        print(f"   {icon} {issue.get('type')}: {issue.get('evidence', '')[:60]}")

    def run_all_tests(self, full: bool = False) -> Dict:
        """Run all security tests"""
        print("\n" + "=" * 60)
        print("METERSQUARE SECURITY PENETRATION TEST")
        print("=" * 60)
        print(f"Target: {self.base_url}")
        print(f"Time: {datetime.now().isoformat()}")
        print(f"Mode: {'Full' if full else 'Quick'}")

        all_issues = []

        # Run tests
        all_issues.extend(self.test_sql_injection())
        all_issues.extend(self.test_xss())
        all_issues.extend(self.test_auth_bypass())
        all_issues.extend(self.test_idor())
        all_issues.extend(self.test_rate_limiting())
        all_issues.extend(self.test_security_headers())
        all_issues.extend(self.test_sensitive_data_exposure())

        # Generate report
        report = self._generate_report(all_issues)
        self._print_summary(report)

        return report

    def _generate_report(self, issues: List[Dict]) -> Dict:
        """Generate test report"""
        critical = len([i for i in issues if i.get('severity') == 'CRITICAL'])
        high = len([i for i in issues if i.get('severity') == 'HIGH'])
        medium = len([i for i in issues if i.get('severity') == 'MEDIUM'])
        low = len([i for i in issues if i.get('severity') == 'LOW'])

        return {
            'timestamp': datetime.now().isoformat(),
            'target': self.base_url,
            'summary': {
                'total_tests': self.passed + self.failed,
                'passed': self.passed,
                'failed': self.failed,
                'total_issues': len(issues),
                'critical': critical,
                'high': high,
                'medium': medium,
                'low': low
            },
            'issues': issues,
            'risk_level': 'CRITICAL' if critical > 0 else 'HIGH' if high > 0 else 'MEDIUM' if medium > 0 else 'LOW' if low > 0 else 'SAFE'
        }

    def _print_summary(self, report: Dict):
        """Print test summary"""
        print("\n" + "=" * 60)
        print("TEST SUMMARY")
        print("=" * 60)

        s = report['summary']
        print(f"\nTests Run: {s['total_tests']}")
        print(f"Passed: {s['passed']}")
        print(f"Failed: {s['failed']}")

        print(f"\nVulnerabilities Found: {s['total_issues']}")
        print(f"  - Critical: {s['critical']}")
        print(f"  - High: {s['high']}")
        print(f"  - Medium: {s['medium']}")
        print(f"  - Low: {s['low']}")

        risk = report['risk_level']
        risk_colors = {
            'CRITICAL': '[!!!]',
            'HIGH': '[!!]',
            'MEDIUM': '[!]',
            'LOW': '[.]',
            'SAFE': '[OK]'
        }
        print(f"\nOverall Risk Level: {risk_colors.get(risk, '')} {risk}")
        print("=" * 60)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='MeterSquare Security Penetration Tester')
    parser.add_argument('--url', default='http://localhost:8000', help='Target URL')
    parser.add_argument('--full', action='store_true', help='Run full test suite')
    parser.add_argument('--output', help='Output file for JSON report')

    args = parser.parse_args()

    tester = SecurityPenTester(args.url)
    report = tester.run_all_tests(full=args.full)

    if args.output:
        with open(args.output, 'w') as f:
            json.dump(report, f, indent=2)
        print(f"\nReport saved to: {args.output}")

    # Exit with error code if critical/high issues found
    if report['summary']['critical'] > 0 or report['summary']['high'] > 0:
        sys.exit(1)
    sys.exit(0)
