import { apiClient } from '@/api/config';
import { AxiosError } from 'axios';

// Interfaces
export interface InventoryMaterial {
  inventory_material_id?: number;
  material_code?: string;  // Auto-generated by backend
  material_name: string;
  brand?: string;
  size?: string;
  category?: string;
  unit: string;
  current_stock: number;
  backup_stock?: number;  // Partially usable/damaged stock
  backup_condition_notes?: string;  // Description of backup stock condition
  min_stock_level?: number;
  unit_price: number;
  description?: string;
  is_active?: boolean;
  is_returnable?: boolean;  // Whether material can be returned/reused
  created_at?: string;
  created_by?: string;
  last_modified_at?: string;
  last_modified_by?: string;
}

export interface InventoryTransaction {
  inventory_transaction_id?: number;
  inventory_material_id: number;
  transaction_type: 'PURCHASE' | 'WITHDRAWAL';
  quantity: number;
  unit_price: number;
  total_amount: number;
  reference_number?: string;
  project_id?: number;
  notes?: string;
  delivery_note_url?: string;  // URL to delivery note/invoice file
  // Transport/Delivery fields (for vendor deliveries - Production Manager role)
  driver_name?: string;
  vehicle_number?: string;
  transport_fee?: number;
  transport_notes?: string;
  delivery_batch_ref?: string;  // e.g., "DB-2026-001"
  created_at?: string;
  created_by?: string;
}

export interface CustomUnit {
  unit_id?: number;
  value: string;
  label: string;
  created_at?: string;
  created_by?: string;
}

export interface InternalMaterialRequest {
  request_id?: number;
  request_number?: number;
  project_id: number;
  request_buyer_id: number;
  material_name: string;
  quantity: number;
  brand?: string;
  size?: string;
  status?: 'PENDING' | 'APPROVED' | 'REJECTED' | 'DISPATCHED' | 'FULFILLED' | 'PROCUREMENT_INITIATED' | 'DN_PENDING' | 'send_request' | 'awaiting_vendor_delivery' | 'approved' | 'rejected' | 'dn_pending' | 'dispatched' | 'fulfilled';
  inventory_material_id?: number;
  inventory_transaction_id?: number;
  approved_by?: string;
  approved_at?: string;
  expected_delivery_date?: string;
  dispatch_date?: string;
  actual_delivery_date?: string;
  rejected_by?: string;
  rejected_at?: string;
  rejection_reason?: string;
  notes?: string;
  request_send?: boolean;
  created_at?: string;
  created_by?: string;
  last_modified_at?: string;
  last_modified_by?: string;
  // Vendor Delivery Routing fields (from buyer completing PO)
  source_type?: 'manual' | 'from_vendor_delivery';
  vendor_delivery_confirmed?: boolean;
  final_destination_site?: string;
  intended_recipient_name?: string;  // Site engineer selected by buyer
  routed_by_buyer_id?: number;
  routed_to_store_at?: string;
  cr_id?: number;  // Change Request ID linked to this request
  // Enriched fields from backend
  project_details?: {
    project_id: number;
    project_name: string;
    project_code: string;
    location?: string;
    area?: string;
    site_supervisor?: {  // First/primary site supervisor (for backward compatibility)
      user_id: number;
      full_name: string;
      email: string;
    };
    site_supervisors?: Array<{  // All site supervisors assigned to this project
      user_id: number;
      full_name: string;
      email: string;
    }>;
    project_managers?: Array<{
      user_id: number;
      full_name: string;
      email: string;
    }>;
  };
  requester_details?: {
    user_id: number;
    full_name: string;
    email: string;
  };
  material_details?: {
    material_code: string;
    material_name: string;
    current_stock: number;
    previous_stock: number;
    updated_stock: number;
    deducted_quantity: number;
    unit: string;
    unit_price: number;
  };
  // Grouped Materials fields (for PO with multiple materials)
  po_child_id?: number;
  materials_data?: Array<{
    material_name: string;
    quantity: number;
    brand?: string;
    size?: string;
    unit?: string;
  }>;
  materials_count?: number;
}

export type MaterialCondition = 'Good' | 'Damaged' | 'Defective';
export type DisposalStatus = 'in_transit' | 'pending_approval' | 'approved' | 'pending_review' | 'approved_disposal' | 'disposed' | 'sent_for_repair' | 'repaired' | 'rejected' | 'backup_added' | null;

export interface MaterialReturn {
  return_id?: number;
  inventory_material_id: number;
  project_id: number;
  quantity: number;
  condition: MaterialCondition;
  add_to_stock: boolean;
  return_reason?: string;
  reference_number?: string;
  notes?: string;
  disposal_status?: DisposalStatus;
  disposal_reviewed_by?: string;
  disposal_reviewed_at?: string;
  disposal_notes?: string;
  disposal_value?: number;
  created_at?: string;
  created_by?: string;
  inventory_transaction_id?: number;
  // Enriched fields from backend
  material_name?: string;
  material_code?: string;
  unit?: string;
  project_details?: {
    project_id: number;
    project_name: string;
    project_code: string;
    location?: string;
  };
}

export interface CreateMaterialReturnData {
  inventory_material_id: number;
  project_id: number;
  quantity: number;
  condition: MaterialCondition;
  add_to_stock?: boolean;
  return_reason?: string;
  reference_number?: string;
  notes?: string;
}

export interface ReviewDisposalData {
  action: 'approve' | 'backup';  // approve = disposal, backup = add to backup stock
  disposal_value?: number;
  notes?: string;
  usable_quantity?: number;  // For backup: how many items are still usable
}

export interface DispatchedMaterial {
  inventory_material_id: number;
  material_code: string;
  material_name: string;
  brand?: string;
  unit: string;
  is_returnable: boolean;
  dispatched_quantity: number;
  returned_quantity: number;
  returnable_quantity: number;
}

// ==================== DELIVERY NOTE INTERFACES ====================

export type DeliveryNoteStatus = 'DRAFT' | 'ISSUED' | 'IN_TRANSIT' | 'DELIVERED' | 'PARTIAL' | 'CANCELLED';

export interface DeliveryNoteItem {
  item_id?: number;
  delivery_note_id?: number;
  inventory_material_id: number;
  internal_request_id?: number;
  quantity: number;
  unit_price?: number;
  notes?: string;
  quantity_received?: number;
  inventory_transaction_id?: number;
  // Enriched fields
  material_code?: string;
  material_name?: string;
  brand?: string;
  unit?: string;
}

export interface MaterialDeliveryNote {
  delivery_note_id?: number;
  delivery_note_number?: string;
  project_id: number;
  delivery_date: string;
  attention_to?: string;
  delivery_from?: string;
  requested_by?: string;
  request_date?: string;
  vehicle_number?: string;
  driver_name?: string;
  driver_contact?: string;
  delivery_note_url?: string;
  prepared_by?: string;
  checked_by?: string;
  status?: DeliveryNoteStatus;
  notes?: string;
  received_by?: string;
  received_at?: string;
  receiver_notes?: string;
  created_at?: string;
  created_by?: string;
  last_modified_at?: string;
  last_modified_by?: string;
  issued_at?: string;
  issued_by?: string;
  dispatched_at?: string;
  dispatched_by?: string;
  items?: DeliveryNoteItem[];
  total_items?: number;
  // Transport fields
  transport_fee?: number;
  delivery_batch_ref?: string;
  project_details?: {
    project_id: number;
    project_name: string;
    project_code: string;
    location?: string;
    project_managers?: Array<{
      user_id: number;
      full_name: string;
      email: string;
    }>;
  };
}

export interface CreateDeliveryNoteData {
  project_id: number;
  delivery_date: string;
  attention_to?: string;
  delivery_from?: string;
  requested_by?: string;
  request_date?: string;
  vehicle_number?: string;
  driver_name?: string;
  driver_contact?: string;
  checked_by?: string;
  notes?: string;
  // Transport fields
  transport_fee?: number;
  delivery_batch_ref?: string;
}

export interface AddDeliveryNoteItemData {
  inventory_material_id: number;
  quantity: number;
  internal_request_id?: number;
  notes?: string;
}

// ==================== CONFIG INTERFACES ====================

export interface InventoryConfig {
  store_name: string;
  company_name: string;
  currency: string;
  delivery_note_prefix: string;
}

// ==================== PROJECT INTERFACES ====================

export interface ProjectManager {
  user_id: number;
  full_name: string;
  email: string;
}

export interface ProjectWithManagers {
  project_id: number;
  project_name: string;
  project_code: string;
  location?: string;
  client?: string;
  user_id?: number[] | null;  // Project manager IDs
  mep_supervisor_id?: number[] | null;  // MEP supervisor IDs
  site_supervisor_id?: number | null;  // Site supervisor ID
  project_managers?: ProjectManager[];  // Enriched manager details
  mep_supervisors?: ProjectManager[];  // Enriched MEP supervisor details
  site_supervisors?: ProjectManager[];  // Enriched site supervisor/engineer details
}

// Simple in-memory cache for frequently accessed data
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
}

class SimpleCache {
  private cache: Map<string, CacheEntry<unknown>> = new Map();
  private defaultTTL = 5 * 60 * 1000; // 5 minutes default TTL
  private maxSize = 100; // Max cache entries to prevent memory issues

  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;

    // Check TTL using stored TTL value
    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.data as T;
  }

  set<T>(key: string, data: T, ttl?: number): void {
    // Enforce size limit - remove oldest entry if at capacity
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey) this.cache.delete(firstKey);
    }

    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl: ttl || this.defaultTTL
    });
  }

  invalidate(key: string): void {
    this.cache.delete(key);
  }

  invalidatePattern(pattern: string): void {
    const regex = new RegExp(pattern);
    const keysToDelete: string[] = [];
    this.cache.forEach((_, key) => {
      if (regex.test(key)) {
        keysToDelete.push(key);
      }
    });
    keysToDelete.forEach(key => this.cache.delete(key));
  }

  clear(): void {
    this.cache.clear();
  }
}

class InventoryService {
  private cache = new SimpleCache();

  private getAuthHeader() {
    return {
      'Authorization': `Bearer ${localStorage.getItem('access_token')}`,
      'Content-Type': 'application/json'
    };
  }

  /**
   * Clear all cached data - call when user logs out or when data should be refreshed
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Invalidate specific cache entries after mutations
   */
  invalidateCache(patterns: string[]): void {
    patterns.forEach(pattern => this.cache.invalidatePattern(pattern));
  }

  // ==================== INVENTORY MATERIAL METHODS ====================

  /**
   * Create a new inventory material
   */
  async createInventoryItem(material: Omit<InventoryMaterial, 'inventory_material_id'>): Promise<InventoryMaterial> {
    try {
      const response = await apiClient.post(
        `/add_item_inventory`,
        material,
        { headers: this.getAuthHeader() }
      );
      // Backend returns { message: '...', material: {...} }
      return response.data.material;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error creating inventory item:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to create inventory item'
      );
    }
  }

  /**
   * Get all inventory materials (with optional pagination)
   */
  async getAllInventoryItems(params?: {
    page?: number;
    limit?: number;
    search?: string;
    category?: string;
    is_active?: boolean;
    low_stock?: boolean;
  }): Promise<InventoryMaterial[]> {
    try {
      const queryParams = new URLSearchParams();
      if (params?.page) queryParams.append('page', params.page.toString());
      if (params?.limit) queryParams.append('limit', params.limit.toString());
      if (params?.search) queryParams.append('search', params.search);
      if (params?.category) queryParams.append('category', params.category);
      if (params?.is_active !== undefined) queryParams.append('is_active', params.is_active.toString());
      if (params?.low_stock !== undefined) queryParams.append('low_stock', params.low_stock.toString());

      const response = await apiClient.get(
        `/all_item_inventory${queryParams.toString() ? '?' + queryParams.toString() : ''}`,
        { headers: this.getAuthHeader() }
      );
      // Backend returns { materials: [...], total: number }
      return response.data.materials || [];
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching inventory items:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch inventory items'
      );
    }
  }

  /**
   * Get paginated inventory materials with metadata
   */
  async getInventoryItemsPaginated(params: {
    page: number;
    limit: number;
    search?: string;
    category?: string;
    is_active?: boolean;
    low_stock?: boolean;
  }): Promise<{
    materials: InventoryMaterial[];
    total: number;
    page: number;
    limit: number;
    total_pages: number;
    has_next: boolean;
    has_prev: boolean;
  }> {
    try {
      const queryParams = new URLSearchParams();
      queryParams.append('page', params.page.toString());
      queryParams.append('limit', params.limit.toString());
      if (params.search) queryParams.append('search', params.search);
      if (params.category) queryParams.append('category', params.category);
      if (params.is_active !== undefined) queryParams.append('is_active', params.is_active.toString());
      if (params.low_stock !== undefined) queryParams.append('low_stock', params.low_stock.toString());

      const response = await apiClient.get(
        `/all_item_inventory?${queryParams.toString()}`,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching paginated inventory items:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch inventory items'
      );
    }
  }

  /**
   * Get a specific inventory item by ID
   */
  async getInventoryItemById(id: number): Promise<InventoryMaterial> {
    try {
      const response = await apiClient.get(
        `/inventory/${id}`,
        { headers: this.getAuthHeader() }
      );
      // Backend returns { material: {...} }
      return response.data.material;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching inventory item:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch inventory item'
      );
    }
  }

  /**
   * Update an inventory item
   */
  async updateInventoryItem(id: number, material: Partial<InventoryMaterial>): Promise<InventoryMaterial> {
    try {
      const response = await apiClient.put(
        `/inventory/${id}`,
        material,
        { headers: this.getAuthHeader() }
      );
      // Backend returns { message: '...', material: {...} }
      return response.data.material;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error updating inventory item:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to update inventory item'
      );
    }
  }

  /**
   * Delete an inventory item
   */
  async deleteInventoryItem(id: number): Promise<{ success: boolean; message: string }> {
    try {
      const response = await apiClient.delete(
        `/inventory/${id}`,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error deleting inventory item:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to delete inventory item'
      );
    }
  }

  /**
   * Get transaction history for an item
   */
  async getItemTransactionHistory(id: number): Promise<InventoryTransaction[]> {
    try {
      const response = await apiClient.get(
        `/inventory/${id}/history`,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching transaction history:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch transaction history'
      );
    }
  }

  // ==================== INVENTORY TRANSACTION METHODS ====================

  /**
   * Create a new inventory transaction
   */
  async createTransaction(transaction: Omit<InventoryTransaction, 'inventory_transaction_id'>): Promise<InventoryTransaction> {
    try {
      const response = await apiClient.post(
        `/transactions`,
        transaction,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error creating transaction:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to create transaction'
      );
    }
  }

  /**
   * Create a transaction with file upload
   * Uploads delivery note to Supabase Storage and creates transaction with file URL
   */
  async createTransactionWithFile(
    transaction: Omit<InventoryTransaction, 'inventory_transaction_id'>,
    deliveryNoteFile: File | null
  ): Promise<InventoryTransaction> {
    try {
      // Create FormData to send file and transaction data to backend
      const formData = new FormData();

      // Add all transaction fields to FormData
      formData.append('inventory_material_id', transaction.inventory_material_id.toString());
      formData.append('transaction_type', transaction.transaction_type);
      formData.append('quantity', transaction.quantity.toString());
      formData.append('unit_price', transaction.unit_price.toString());
      formData.append('total_amount', transaction.total_amount.toString());

      if (transaction.reference_number) {
        formData.append('reference_number', transaction.reference_number);
      }
      if (transaction.notes) {
        formData.append('notes', transaction.notes);
      }

      // Add transport/delivery fields if provided
      if (transaction.driver_name) {
        formData.append('driver_name', transaction.driver_name);
      }
      if (transaction.vehicle_number) {
        formData.append('vehicle_number', transaction.vehicle_number);
      }
      if (transaction.transport_fee !== undefined && transaction.transport_fee !== null) {
        formData.append('transport_fee', transaction.transport_fee.toString());
      }
      if (transaction.transport_notes) {
        formData.append('transport_notes', transaction.transport_notes);
      }
      if (transaction.delivery_batch_ref) {
        formData.append('delivery_batch_ref', transaction.delivery_batch_ref);
      }

      // Add file if provided, OR use existing URL
      if (deliveryNoteFile) {
        formData.append('delivery_note_file', deliveryNoteFile);
      } else if (transaction.delivery_note_url) {
        // Use existing delivery note URL from batch
        formData.append('delivery_note_url', transaction.delivery_note_url);
      }

      // Send to backend - backend will handle Supabase upload
      const response = await apiClient.post(
        `/transactions`,
        formData,
        {
          headers: {
            ...this.getAuthHeader(),
            // Don't set Content-Type - let browser set it with boundary for multipart/form-data
          }
        }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error creating transaction with file:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to create transaction with file'
      );
    }
  }

  /**
   * Get all inventory transactions
   */
  async getAllTransactions(): Promise<InventoryTransaction[]> {
    try {
      const response = await apiClient.get(
        `/transactions`,
        { headers: this.getAuthHeader() }
      );
      // Backend returns { transactions: [...] } or array directly
      return response.data.transactions || response.data || [];
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching transactions:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch transactions'
      );
    }
  }

  /**
   * Get inventory transactions with filters (alias method for StockInPage compatibility)
   */
  async getAllInventoryTransactions(params?: {
    transaction_type?: 'PURCHASE' | 'WITHDRAWAL';
    inventory_material_id?: number;
    project_id?: number;
  }): Promise<{ transactions: InventoryTransaction[], total: number }> {
    try {
      const queryParams = new URLSearchParams();
      if (params?.transaction_type) {
        queryParams.append('transaction_type', params.transaction_type);
      }
      if (params?.inventory_material_id) {
        queryParams.append('inventory_material_id', params.inventory_material_id.toString());
      }
      if (params?.project_id) {
        queryParams.append('project_id', params.project_id.toString());
      }

      const response = await apiClient.get(
        `/transactions${queryParams.toString() ? '?' + queryParams.toString() : ''}`,
        { headers: this.getAuthHeader() }
      );
      // Backend returns { transactions: [...], total: number }
      return {
        transactions: response.data.transactions || response.data || [],
        total: response.data.total || response.data.transactions?.length || 0
      };
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching inventory transactions:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch inventory transactions'
      );
    }
  }

  /**
   * Create inventory transaction (alias method for StockInPage compatibility)
   */
  async createInventoryTransaction(transaction: Omit<InventoryTransaction, 'inventory_transaction_id'>): Promise<InventoryTransaction> {
    return this.createTransaction(transaction);
  }

  /**
   * Get a specific transaction by ID
   */
  async getTransactionById(id: number): Promise<InventoryTransaction> {
    try {
      const response = await apiClient.get(
        `/transactions/${id}`,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching transaction:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch transaction'
      );
    }
  }

  // ==================== INTERNAL MATERIAL REQUEST METHODS ====================

  /**
   * Create a new internal material request
   */
  async createInternalRequest(request: Omit<InternalMaterialRequest, 'request_id'>): Promise<InternalMaterialRequest> {
    try {
      const response = await apiClient.post(
        `/internal_material_request`,
        request,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error creating internal request:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to create internal request'
      );
    }
  }

  /**
   * Get all internal material requests
   */
  async getAllInternalRequests(): Promise<InternalMaterialRequest[]> {
    try {
      const response = await apiClient.get(
        `/internal_material_requests`,
        { headers: this.getAuthHeader() }
      );
      // Backend returns { requests: [...], total: number }
      return response.data.requests || response.data || [];
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching internal requests:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch internal requests'
      );
    }
  }

  /**
   * Get sent (PENDING) internal requests
   */
  async getSentInternalRequests(): Promise<InternalMaterialRequest[]> {
    try {
      const response = await apiClient.get(
        `/sent_internal_requests`,
        { headers: this.getAuthHeader() }
      );
      // Backend returns { requests: [...], total: number }
      return response.data.requests || response.data || [];
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching sent requests:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch sent requests'
      );
    }
  }

  /**
   * Get a specific internal request by ID
   */
  async getInternalRequestById(id: number): Promise<InternalMaterialRequest> {
    try {
      const response = await apiClient.get(
        `/internal_material/${id}`,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching internal request:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch internal request'
      );
    }
  }

  /**
   * Update an internal material request
   */
  async updateInternalRequest(id: number, request: Partial<InternalMaterialRequest>): Promise<InternalMaterialRequest> {
    try {
      const response = await apiClient.put(
        `/internal_material/${id}`,
        request,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error updating internal request:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to update internal request'
      );
    }
  }

  /**
   * Delete an internal material request
   */
  async deleteInternalRequest(id: number): Promise<{ success: boolean; message: string }> {
    try {
      const response = await apiClient.delete(
        `/internal_material/${id}`,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error deleting internal request:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to delete internal request'
      );
    }
  }

  /**
   * Send an internal request for approval
   */
  async sendInternalRequest(id: number): Promise<{ success: boolean; message: string }> {
    try {
      const response = await apiClient.get(
        `/internal_material/${id}/send`,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error sending internal request:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to send internal request'
      );
    }
  }

  /**
   * Approve an internal request
   */
  async approveInternalRequest(id: number, data?: any): Promise<{ success: boolean; message: string }> {
    try {
      const response = await apiClient.post(
        `/internal_material/${id}/approve`,
        data || {},
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error approving internal request:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to approve internal request'
      );
    }
  }

  /**
   * Reject an internal request
   */
  async rejectInternalRequest(id: number, reason: string): Promise<{ success: boolean; message: string }> {
    try {
      const response = await apiClient.post(
        `/internal_material/${id}/reject`,
        { rejection_reason: reason },
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error rejecting internal request:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to reject internal request'
      );
    }
  }

  /**
   * Dispatch material for a request
   */
  async dispatchMaterial(id: number, data?: any): Promise<{ success: boolean; message: string }> {
    try {
      const response = await apiClient.post(
        `/internal_material/${id}/dispatch`,
        data || {},
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error dispatching material:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to dispatch material'
      );
    }
  }

  /**
   * Check inventory availability for a request
   */
  async checkAvailability(id: number): Promise<any> {
    try {
      const response = await apiClient.get(
        `/internal_material/${id}/check_availability`,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error checking availability:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to check availability'
      );
    }
  }

  /**
   * Issue material from inventory
   */
  async issueMaterial(id: number, data?: any): Promise<{ success: boolean; message: string }> {
    try {
      const response = await apiClient.post(
        `/internal_material/${id}/issue_material`,
        data || {},
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error issuing material:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to issue material'
      );
    }
  }

  // ==================== SUMMARY METHODS ====================

  /**
   * Get inventory summary
   */
  async getInventorySummary(): Promise<any> {
    try {
      const response = await apiClient.get(
        `/summary`,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching inventory summary:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch inventory summary'
      );
    }
  }

  /**
   * Get comprehensive dashboard data in a single API call
   */
  async getDashboardData(): Promise<any> {
    try {
      const response = await apiClient.get(
        `/inventory/dashboard`,
        { headers: this.getAuthHeader() }
      );
      return response.data.dashboard;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching dashboard data:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch dashboard data'
      );
    }
  }

  // ==================== MATERIAL RETURN METHODS ====================

  /**
   * Create a new material return with condition tracking
   */
  async createMaterialReturn(data: CreateMaterialReturnData): Promise<{
    return: MaterialReturn;
    stock_updated: boolean;
    new_stock_level: number;
    project_details: any;
  }> {
    try {
      const response = await apiClient.post(
        `/material_return`,
        data,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error creating material return:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to create material return'
      );
    }
  }

  /**
   * Get dispatched materials for a project that can be returned
   * Returns materials with dispatched, returned, and returnable quantities
   */
  async getDispatchedMaterialsForProject(projectId: number): Promise<{
    project_id: number;
    materials: DispatchedMaterial[];
    total: number;
  }> {
    try {
      const response = await apiClient.get(
        `/project/${projectId}/dispatched_materials`,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching dispatched materials:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch dispatched materials'
      );
    }
  }

  /**
   * Get all material returns with optional filters
   */
  async getAllMaterialReturns(filters?: {
    project_id?: number;
    condition?: MaterialCondition;
    disposal_status?: DisposalStatus;
    inventory_material_id?: number;
    start_date?: string;
    end_date?: string;
  }): Promise<{ returns: MaterialReturn[]; total: number }> {
    try {
      const params = new URLSearchParams();
      if (filters?.project_id) params.append('project_id', filters.project_id.toString());
      if (filters?.condition) params.append('condition', filters.condition);
      if (filters?.disposal_status) params.append('disposal_status', filters.disposal_status);
      if (filters?.inventory_material_id) params.append('inventory_material_id', filters.inventory_material_id.toString());
      if (filters?.start_date) params.append('start_date', filters.start_date);
      if (filters?.end_date) params.append('end_date', filters.end_date);

      const response = await apiClient.get(
        `/material_returns?${params.toString()}`,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching material returns:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch material returns'
      );
    }
  }

  /**
   * Get a specific material return by ID
   */
  async getMaterialReturnById(id: number): Promise<MaterialReturn> {
    try {
      const response = await apiClient.get(
        `/material_return/${id}`,
        { headers: this.getAuthHeader() }
      );
      return response.data.return;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching material return:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch material return'
      );
    }
  }

  /**
   * Get all material returns pending disposal review
   */
  async getPendingDisposalReturns(): Promise<{ pending_disposals: MaterialReturn[]; total: number }> {
    try {
      const response = await apiClient.get(
        `/material_returns/pending_disposal`,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching pending disposals:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch pending disposals'
      );
    }
  }

  /**
   * Review and approve/repair disposal of damaged/defective materials
   */
  async reviewDisposal(id: number, data: ReviewDisposalData): Promise<MaterialReturn> {
    try {
      const response = await apiClient.post(
        `/material_return/${id}/review_disposal`,
        data,
        { headers: this.getAuthHeader() }
      );
      return response.data.return;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error reviewing disposal:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to review disposal'
      );
    }
  }

  /**
   * Mark a material return as physically disposed
   */
  async markAsDisposed(id: number, notes?: string): Promise<MaterialReturn> {
    try {
      const response = await apiClient.post(
        `/material_return/${id}/mark_disposed`,
        { notes },
        { headers: this.getAuthHeader() }
      );
      return response.data.return;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error marking as disposed:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to mark as disposed'
      );
    }
  }

  /**
   * Mark material as repaired and move from backup stock to main stock
   * Called when PM confirms the repair is complete
   */
  async addRepairedToStock(id: number, notes?: string): Promise<{
    return: MaterialReturn;
    new_stock_level: number;
    new_backup_stock: number;
  }> {
    try {
      const response = await apiClient.post(
        `/material_return/${id}/add_to_stock`,
        { notes },
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error adding repaired to stock:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to add repaired material to stock'
      );
    }
  }

  /**
   * Request disposal from repair - when material cannot be repaired
   * Sends to TD for disposal approval
   */
  async requestDisposalFromRepair(id: number, notes?: string): Promise<{
    message: string;
    return: MaterialReturn;
  }> {
    try {
      const response = await apiClient.post(
        `/material_return/${id}/request_disposal`,
        { notes },
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error requesting disposal:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to request disposal'
      );
    }
  }

  /**
   * Approve a Good condition return and add to stock (PM action)
   */
  async approveReturnToStock(id: number, notes?: string): Promise<{
    return: MaterialReturn;
    new_stock_level: number;
  }> {
    try {
      const response = await apiClient.post(
        `/material_return/${id}/approve`,
        { notes },
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error approving return:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to approve return'
      );
    }
  }

  /**
   * Reject a return (PM action)
   */
  async rejectReturn(id: number, notes?: string): Promise<MaterialReturn> {
    try {
      const response = await apiClient.post(
        `/material_return/${id}/reject`,
        { notes },
        { headers: this.getAuthHeader() }
      );
      return response.data.return;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error rejecting return:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to reject return'
      );
    }
  }

  /**
   * Get incoming RDNs (Return Delivery Notes) from Site Engineers
   */
  async getIncomingRDNs(): Promise<{ return_delivery_notes: any[]; total: number }> {
    try {
      const response = await apiClient.get('/pm-return-delivery-notes', {
        headers: this.getAuthHeader()
      });
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching incoming RDNs:', axiosError);
      return { return_delivery_notes: [], total: 0 };
    }
  }

  /**
   * Process all RDN items in a single request (batch operation)
   * This reduces N API calls to 1 for better performance
   */
  async processAllRDNItems(returnNoteId: number, items: Array<{
    item_id: number;
    action: 'approve' | 'backup' | 'reject';
    notes?: string;
    usable_quantity?: number;
  }>): Promise<{
    message: string;
    processed_items: Array<{ item_id: number; action: string; material_return_id: number }>;
    errors: string[];
    rdn_status: string;
  }> {
    try {
      const response = await apiClient.post(
        `/return_delivery_note/${returnNoteId}/process_all_items`,
        { items },
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error processing RDN items:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to process RDN items'
      );
    }
  }

  // ==================== PROJECT METHODS ====================

  /**
   * Get all projects with full details (for dropdown selections and manager lookup)
   */
  async getAllProjects(forceRefresh = false): Promise<ProjectWithManagers[]> {
    const cacheKey = 'projects:all';

    // Return cached data if available and not forcing refresh
    if (!forceRefresh) {
      const cached = this.cache.get<ProjectWithManagers[]>(cacheKey);
      if (cached) return cached;
    }

    try {
      const response = await apiClient.get(
        `/all_project`,
        { headers: this.getAuthHeader() }
      );
      // Backend returns { projects: [...] } or array directly
      const projects = response.data.projects || response.data || [];

      // Cache the result
      this.cache.set(cacheKey, projects);

      return projects;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching projects:', axiosError);
      // Return empty array on error to allow page to load
      return [];
    }
  }

  // ==================== INVENTORY CONFIG METHODS ====================

  /**
   * Get inventory configuration (store name, currency, etc.)
   * Cached for 5 minutes as this data rarely changes
   */
  async getInventoryConfig(forceRefresh = false): Promise<InventoryConfig> {
    const cacheKey = 'inventory:config';

    // Return cached data if available and not forcing refresh
    if (!forceRefresh) {
      const cached = this.cache.get<InventoryConfig>(cacheKey);
      if (cached) return cached;
    }

    try {
      const response = await apiClient.get(
        `/inventory/config`,
        { headers: this.getAuthHeader() }
      );
      const config = response.data;

      // Cache the result
      this.cache.set(cacheKey, config);

      return config;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching inventory config:', axiosError);
      // Return defaults on error
      return {
        store_name: 'M2 Store',
        company_name: 'MeterSquare ERP',
        currency: 'AED',
        delivery_note_prefix: 'MDN'
      };
    }
  }

  // ==================== MATERIAL DELIVERY NOTE METHODS ====================

  /**
   * Create a new delivery note
   */
  async createDeliveryNote(data: CreateDeliveryNoteData, file?: File | null): Promise<MaterialDeliveryNote> {
    try {
      // If file is provided, use FormData
      if (file) {
        const formData = new FormData();
        formData.append('delivery_note_file', file);

        // Append all data fields
        Object.entries(data).forEach(([key, value]) => {
          if (value !== undefined && value !== null) {
            formData.append(key, String(value));
          }
        });

        const response = await apiClient.post(
          `/delivery_notes`,
          formData,
          {
            headers: {
              ...this.getAuthHeader(),
              'Content-Type': 'multipart/form-data'
            }
          }
        );
        return response.data.delivery_note;
      } else {
        // Regular JSON request
        const response = await apiClient.post(
          `/delivery_notes`,
          data,
          { headers: this.getAuthHeader() }
        );
        return response.data.delivery_note;
      }
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error creating delivery note:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to create delivery note'
      );
    }
  }

  /**
   * Get all delivery notes with optional filters
   */
  async getAllDeliveryNotes(filters?: {
    project_id?: number;
    status?: DeliveryNoteStatus;
    start_date?: string;
    end_date?: string;
  }): Promise<{ delivery_notes: MaterialDeliveryNote[]; total: number }> {
    try {
      const params = new URLSearchParams();
      if (filters?.project_id) params.append('project_id', filters.project_id.toString());
      if (filters?.status) params.append('status', filters.status);
      if (filters?.start_date) params.append('start_date', filters.start_date);
      if (filters?.end_date) params.append('end_date', filters.end_date);

      const response = await apiClient.get(
        `/delivery_notes?${params.toString()}`,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching delivery notes:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch delivery notes'
      );
    }
  }

  /**
   * Get a specific delivery note by ID
   */
  async getDeliveryNoteById(id: number): Promise<MaterialDeliveryNote> {
    try {
      const response = await apiClient.get(
        `/delivery_note/${id}`,
        { headers: this.getAuthHeader() }
      );
      return response.data.delivery_note;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching delivery note:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch delivery note'
      );
    }
  }

  /**
   * Update a delivery note
   */
  async updateDeliveryNote(id: number, data: Partial<CreateDeliveryNoteData>): Promise<MaterialDeliveryNote> {
    try {
      const response = await apiClient.put(
        `/delivery_note/${id}`,
        data,
        { headers: this.getAuthHeader() }
      );
      return response.data.delivery_note;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error updating delivery note:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to update delivery note'
      );
    }
  }

  /**
   * Delete a delivery note
   */
  async deleteDeliveryNote(id: number): Promise<{ message: string }> {
    try {
      const response = await apiClient.delete(
        `/delivery_note/${id}`,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error deleting delivery note:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to delete delivery note'
      );
    }
  }

  /**
   * Add an item to a delivery note
   */
  async addDeliveryNoteItem(deliveryNoteId: number, data: AddDeliveryNoteItemData): Promise<{
    item: DeliveryNoteItem;
    delivery_note: MaterialDeliveryNote;
  }> {
    try {
      const response = await apiClient.post(
        `/delivery_note/${deliveryNoteId}/items`,
        data,
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error adding item to delivery note:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to add item to delivery note'
      );
    }
  }

  /**
   * Add multiple items to a delivery note in a single request (batch operation)
   * This reduces N API calls to 1 for better performance
   */
  async addDeliveryNoteItemsBulk(deliveryNoteId: number, items: AddDeliveryNoteItemData[]): Promise<{
    message: string;
    added_items: DeliveryNoteItem[];
    errors: string[];
    delivery_note: MaterialDeliveryNote;
  }> {
    try {
      const response = await apiClient.post(
        `/delivery_note/${deliveryNoteId}/items/bulk`,
        { items },
        { headers: this.getAuthHeader() }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error adding items to delivery note:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to add items to delivery note'
      );
    }
  }

  /**
   * Update an item in a delivery note
   */
  async updateDeliveryNoteItem(deliveryNoteId: number, itemId: number, data: {
    quantity?: number;
    notes?: string;
  }): Promise<DeliveryNoteItem> {
    try {
      const response = await apiClient.put(
        `/delivery_note/${deliveryNoteId}/items/${itemId}`,
        data,
        { headers: this.getAuthHeader() }
      );
      return response.data.item;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error updating delivery note item:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to update delivery note item'
      );
    }
  }

  /**
   * Remove an item from a delivery note
   */
  async removeDeliveryNoteItem(deliveryNoteId: number, itemId: number): Promise<MaterialDeliveryNote> {
    try {
      const response = await apiClient.delete(
        `/delivery_note/${deliveryNoteId}/items/${itemId}`,
        { headers: this.getAuthHeader() }
      );
      return response.data.delivery_note;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error removing delivery note item:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to remove delivery note item'
      );
    }
  }

  /**
   * Issue a delivery note (deducts stock)
   */
  async issueDeliveryNote(id: number): Promise<MaterialDeliveryNote> {
    try {
      const response = await apiClient.post(
        `/delivery_note/${id}/issue`,
        {},
        { headers: this.getAuthHeader() }
      );
      return response.data.delivery_note;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error issuing delivery note:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to issue delivery note'
      );
    }
  }

  /**
   * Dispatch a delivery note (mark as in transit)
   */
  async dispatchDeliveryNote(id: number, data?: {
    vehicle_number?: string;
    driver_name?: string;
    driver_contact?: string;
  }): Promise<MaterialDeliveryNote> {
    try {
      const response = await apiClient.post(
        `/delivery_note/${id}/dispatch`,
        data || {},
        { headers: this.getAuthHeader() }
      );
      return response.data.delivery_note;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error dispatching delivery note:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to dispatch delivery note'
      );
    }
  }

  /**
   * Confirm delivery receipt
   */
  async confirmDelivery(id: number, data?: {
    received_by?: string;
    receiver_notes?: string;
    items_received?: Array<{ item_id: number; quantity_received: number }>;
  }): Promise<MaterialDeliveryNote> {
    try {
      const response = await apiClient.post(
        `/delivery_note/${id}/confirm`,
        data || {},
        { headers: this.getAuthHeader() }
      );
      return response.data.delivery_note;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error confirming delivery:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to confirm delivery'
      );
    }
  }

  /**
   * Cancel a delivery note
   */
  async cancelDeliveryNote(id: number): Promise<MaterialDeliveryNote> {
    try {
      const response = await apiClient.post(
        `/delivery_note/${id}/cancel`,
        {},
        { headers: this.getAuthHeader() }
      );
      return response.data.delivery_note;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error cancelling delivery note:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to cancel delivery note'
      );
    }
  }

  // ==================== STOCK UPDATE METHODS ====================

  /**
   * Update inventory stock quantity (increase or decrease)
   * Used for manual stock adjustments, GRN receiving, etc.
   */
  async updateInventoryStock(
    materialId: number,
    quantity: number,
    operation: 'increase' | 'decrease'
  ): Promise<{ success: boolean; new_stock: number; message: string }> {
    try {
      // TODO: Replace with actual backend API endpoint when available
      // Expected endpoint: PUT /inventory/{id}/stock
      // Expected payload: { quantity, operation }

      // For now, we'll fetch current material and calculate new stock
      const material = await this.getInventoryItemById(materialId);
      const currentStock = material.current_stock || 0;
      const newStock = operation === 'increase'
        ? currentStock + quantity
        : currentStock - quantity;

      // Update the material with new stock
      await this.updateInventoryItem(materialId, {
        current_stock: newStock
      });

      return {
        success: true,
        new_stock: newStock,
        message: `Stock ${operation}d by ${quantity}. New stock: ${newStock}`
      };
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error updating stock:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to update stock'
      );
    }
  }

  /**
   * Get all custom units from database
   */
  async getCustomUnits(): Promise<CustomUnit[]> {
    try {
      const response = await apiClient.get('/boq/custom-units');
      return response.data.custom_units || [];
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error fetching custom units:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to fetch custom units'
      );
    }
  }

  /**
   * Create a new custom unit
   */
  async createCustomUnit(unitValue: string, unitLabel: string): Promise<CustomUnit> {
    try {
      const response = await apiClient.post('/boq/custom-units', {
        unit_value: unitValue,
        unit_label: unitLabel
      });
      return response.data.unit || response.data.custom_unit;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error creating custom unit:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to create custom unit'
      );
    }
  }

  /**
   * Request disposal for damaged/wasted materials from catalog
   */
  async requestMaterialDisposal(
    materialId: number,
    disposalData: {
      quantity: number;
      reason: string;
      notes: string;
      estimated_value: number;
    }
  ): Promise<any> {
    try {
      const response = await apiClient.post(
        `/inventory/materials/${materialId}/request-disposal`,
        disposalData,
        {
          headers: this.getAuthHeader()
        }
      );
      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;
      console.error('Error submitting disposal request:', axiosError);
      throw new Error(
        (axiosError.response?.data as any)?.error || 'Failed to submit disposal request'
      );
    }
  }

}

export const inventoryService = new InventoryService();